// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * API version: 1.30.0
 */

package energyserver




type EnergyPlanContractV3 struct {

	// Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation string `json:"additionalFeeInformation,omitempty"`

	// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel string `json:"pricingModel"`

	// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone string `json:"timeZone,omitempty"`

	// Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation string `json:"variation,omitempty"`

	// Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription string `json:"onExpiryDescription,omitempty"`

	// Payment options for this contract
	PaymentOption []string `json:"paymentOption"`

	IntrinsicGreenPower EnergyPlanContractV3IntrinsicGreenPower `json:"intrinsicGreenPower,omitempty"`

	// Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad []EnergyPlanControlledLoadV2Inner `json:"controlledLoad,omitempty"`

	// Optional list of incentives available for the contract
	Incentives []EnergyPlanIncentivesInner `json:"incentives,omitempty"`

	// Optional list of discounts available for the contract
	Discounts []EnergyPlanDiscountsInner `json:"discounts,omitempty"`

	// Optional list of charges applicable to green power
	GreenPowerCharges []EnergyPlanGreenPowerChargesInner `json:"greenPowerCharges,omitempty"`

	// Eligibility restrictions or requirements
	Eligibility []EnergyPlanEligibilityInner `json:"eligibility,omitempty"`

	// An array of fees applicable to the plan
	Fees []EnergyPlanFeesInner `json:"fees,omitempty"`

	// Array of feed in tariffs for solar power
	SolarFeedInTariff []EnergyPlanSolarFeedInTariffV3Inner `json:"solarFeedInTariff,omitempty"`

	// Array of tariff periods
	TariffPeriod []EnergyPlanTariffPeriodV2Inner `json:"tariffPeriod"`
}

// AssertEnergyPlanContractV3Required checks if the required fields are not zero-ed
func AssertEnergyPlanContractV3Required(obj EnergyPlanContractV3) error {
	elements := map[string]interface{}{
		"pricingModel": obj.PricingModel,
		"isFixed": obj.IsFixed,
		"paymentOption": obj.PaymentOption,
		"tariffPeriod": obj.TariffPeriod,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertEnergyPlanContractV3IntrinsicGreenPowerRequired(obj.IntrinsicGreenPower); err != nil {
		return err
	}
	for _, el := range obj.ControlledLoad {
		if err := AssertEnergyPlanControlledLoadV2InnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Incentives {
		if err := AssertEnergyPlanIncentivesInnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Discounts {
		if err := AssertEnergyPlanDiscountsInnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.GreenPowerCharges {
		if err := AssertEnergyPlanGreenPowerChargesInnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Eligibility {
		if err := AssertEnergyPlanEligibilityInnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Fees {
		if err := AssertEnergyPlanFeesInnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.SolarFeedInTariff {
		if err := AssertEnergyPlanSolarFeedInTariffV3InnerRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.TariffPeriod {
		if err := AssertEnergyPlanTariffPeriodV2InnerRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertEnergyPlanContractV3Constraints checks if the values respects the defined constraints
func AssertEnergyPlanContractV3Constraints(obj EnergyPlanContractV3) error {
	return nil
}
