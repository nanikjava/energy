// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * API version: 1.30.0
 */

package energyserver




type EnergyServicePointDetail struct {

	// The tokenised ID of the service point for use in the CDR APIs.  Created according to the CDR rules for ID permanence
	ServicePointId string `json:"servicePointId"`

	// The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId string `json:"nationalMeteringId"`

	// The classification of the service point as defined in MSATS procedures
	ServicePointClassification string `json:"servicePointClassification"`

	// Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul> 
	ServicePointStatus string `json:"servicePointStatus"`

	// Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode string `json:"jurisdictionCode"`

	// This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator bool `json:"isGenerator,omitempty"`

	// The latest start date from which the constituent data sets of this service point became valid
	ValidFromDate string `json:"validFromDate"`

	// The date and time that the information for this service point was modified
	LastUpdateDateTime string `json:"lastUpdateDateTime"`

	ConsumerProfile EnergyServicePointConsumerProfile `json:"consumerProfile,omitempty"`

	DistributionLossFactor EnergyServicePointDetailDistributionLossFactor `json:"distributionLossFactor"`

	RelatedParticipants []EnergyServicePointDetailRelatedParticipants `json:"relatedParticipants"`

	Location CommonPhysicalAddress `json:"location"`

	// The meters associated with the service point. This may be empty where there are no meters physically installed at the service point
	Meters []EnergyServicePointDetailMeters `json:"meters,omitempty"`
}

// AssertEnergyServicePointDetailRequired checks if the required fields are not zero-ed
func AssertEnergyServicePointDetailRequired(obj EnergyServicePointDetail) error {
	elements := map[string]interface{}{
		"servicePointId": obj.ServicePointId,
		"nationalMeteringId": obj.NationalMeteringId,
		"servicePointClassification": obj.ServicePointClassification,
		"servicePointStatus": obj.ServicePointStatus,
		"jurisdictionCode": obj.JurisdictionCode,
		"validFromDate": obj.ValidFromDate,
		"lastUpdateDateTime": obj.LastUpdateDateTime,
		"distributionLossFactor": obj.DistributionLossFactor,
		"relatedParticipants": obj.RelatedParticipants,
		"location": obj.Location,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertEnergyServicePointConsumerProfileRequired(obj.ConsumerProfile); err != nil {
		return err
	}
	if err := AssertEnergyServicePointDetailDistributionLossFactorRequired(obj.DistributionLossFactor); err != nil {
		return err
	}
	for _, el := range obj.RelatedParticipants {
		if err := AssertEnergyServicePointDetailRelatedParticipantsRequired(el); err != nil {
			return err
		}
	}
	if err := AssertCommonPhysicalAddressRequired(obj.Location); err != nil {
		return err
	}
	for _, el := range obj.Meters {
		if err := AssertEnergyServicePointDetailMetersRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertEnergyServicePointDetailConstraints checks if the values respects the defined constraints
func AssertEnergyServicePointDetailConstraints(obj EnergyServicePointDetail) error {
	return nil
}
