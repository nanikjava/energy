// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * API version: 1.30.0
 */

package energyserver




type EnergyUsageRead struct {

	// Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// Register ID of the meter register where the meter reads are obtained
	RegisterId string `json:"registerId,omitempty"`

	// Register suffix of the meter register where the meter reads are obtained
	RegisterSuffix string `json:"registerSuffix"`

	// Meter id/serial number as it appears in customerâ€™s bill. ID permanence rules do not apply.
	MeterId string `json:"meterId,omitempty"`

	// Indicates whether the energy recorded by this register is created under a Controlled Load regime
	ControlledLoad bool `json:"controlledLoad,omitempty"`

	// Date when the meter reads start in AEST and assumed to start from 12:00 am AEST.
	ReadStartDate string `json:"readStartDate"`

	// Date when the meter reads end in AEST.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate.
	ReadEndDate string `json:"readEndDate,omitempty"`

	// Unit of measure of the meter reads. Refer to Appendix B of <a href='https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la=en&hash=03FCBA0D60E091DE00F2361AE76206EA'>MDFF Specification NEM12 NEM13 v2.1</a> for a list of possible values.
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Specify the type of the meter read data
	ReadUType string `json:"readUType"`

	BasicRead EnergyUsageReadBasicRead `json:"basicRead,omitempty"`

	IntervalRead EnergyUsageReadIntervalRead `json:"intervalRead,omitempty"`
}

// AssertEnergyUsageReadRequired checks if the required fields are not zero-ed
func AssertEnergyUsageReadRequired(obj EnergyUsageRead) error {
	elements := map[string]interface{}{
		"servicePointId": obj.ServicePointId,
		"registerSuffix": obj.RegisterSuffix,
		"readStartDate": obj.ReadStartDate,
		"readUType": obj.ReadUType,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertEnergyUsageReadBasicReadRequired(obj.BasicRead); err != nil {
		return err
	}
	if err := AssertEnergyUsageReadIntervalReadRequired(obj.IntervalRead); err != nil {
		return err
	}
	return nil
}

// AssertEnergyUsageReadConstraints checks if the values respects the defined constraints
func AssertEnergyUsageReadConstraints(obj EnergyUsageRead) error {
	return nil
}
